plugins {
    id 'java'
    id 'application'
    id 'org.ajoberstar.grgit' version '4.1.0'
    id 'checkstyle'
    id 'com.appmattus.markdown' version '0.6.0'
    id 'codenarc'
    id 'nebula.lint' version '16.23.0'
    id 'com.github.spotbugs' version '4.7.1'
    id 'pmd'
    id 'jacoco'
    id 'org.sonarqube' version '3.2.0'
    id 'at.zierler.yamlvalidator' version '1.5.0'
    id 'com.github.ivankohut.git-branch-checks' version '0.0.2'
}

ext {
    javaVersion = JavaVersion.VERSION_15
    junitVersion = '5.7.2'
    checkstyleVersion = '8.42'
    codenarcVersion = '2.0.0'
    spotbugsVersion = '4.2.3'
    pmdVersion = '6.34.0'
    jacocoVersion = '0.8.7'
    lombokVersion = '1.18.20'
    twsApiZipUrl = 'https://interactivebrokers.github.io/downloads/twsapi_macunix.976.01.zip'
    specificationDir = 'src/acceptanceTest/specification'
}

sourceCompatibility = javaVersion
targetCompatibility = javaVersion

repositories {
    mavenCentral()
}

sourceSets {
    acceptanceTest {
        java {
            srcDir 'src/acceptanceTest/java'
        }
        resources {
            srcDirs specificationDir
        }
    }
}

// Download TWS API jar which is not available in public maven repositories
def twsDir = new File("$buildDir/tws/")
def twsApiJar = new File("$twsDir/twsApi.jar")
twsDir.mkdirs()
if (!twsApiJar.exists()) {
    def twsApiZip = new File(twsDir, 'twsapi.zip')
    twsApiZip << new URL(twsApiZipUrl).bytes
    def unzippedDir = "$twsDir/unzipped"
    ant.unzip(src: twsApiZip, dest: unzippedDir, overwrite: 'true')
    twsApiJar << new File("$unzippedDir/IBJts/source/JavaClient/TwsApi.jar").bytes
}

dependencies {
    implementation files(twsApiJar)
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    implementation 'org.cactoos:cactoos:0.50'
    implementation 'commons-io:commons-io:2.8.0'
    implementation 'org.json:json:20210307'
    implementation 'com.jayway.jsonpath:json-path:2.5.0'

    testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
    testImplementation "org.junit.jupiter:junit-jupiter-params:${junitVersion}"
    testImplementation 'org.assertj:assertj-core:3.19.0'
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    testImplementation 'org.mockito:mockito-core:3.10.0'

    acceptanceTestImplementation 'org.fitnesse:fitnesse:20210516'
    acceptanceTestImplementation sourceSets.main.compileClasspath
    acceptanceTestImplementation sourceSets.main.output
    acceptanceTestImplementation sourceSets.test.compileClasspath
    acceptanceTestImplementation sourceSets.test.output
    acceptanceTestAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    acceptanceTestImplementation "com.github.spotbugs:spotbugs-annotations:${spotbugsVersion}"
    acceptanceTestImplementation 'junit:junit:4.13.2'
}

gitBranchChecks {
    branchPattern = ~/(master)|(feature\/#\d+\/[a-z0-9\-]+)/
    messagePattern = ~/#\d+ [A-Z0-9]\S* \S.*/
}

check {
    dependsOn checkBranchName, checkCommitMessages, checkNoMergeCommits
}

jar {
    manifest {
        attributes(
                'Main-Class': 'sk.ivankohut.quantifa.Application'
        )
    }
    // create fat-jar
    from {
        configurations.runtimeClasspath.collect { file -> file.directory ? file : zipTree(file) }
    }
}

jacoco {
    toolVersion jacocoVersion
}

jacocoTestReport {
    dependsOn test
    reports {
        html.enabled false
        xml.enabled true
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

checkstyle {
    toolVersion checkstyleVersion
}

task checkstyleRoot(type: Checkstyle) {
    source = rootDir
    classpath = files()
    configFile = file('config/checkstyle/checkstyle-root.xml')
    exclude '**/build/**', '.idea/**', 'out/**', '**/.gradle/**', 'gradle/**', 'gradlew', 'gradlew.bat', '**/*.md',
            "${specificationDir}/**/*.zip", "${specificationDir}/GradleClassPath.wiki"
}

check {
    dependsOn checkstyleRoot
}

codenarc {
    toolVersion codenarcVersion
}

task codenarcGradle(type: CodeNarc) {
    compilationClasspath += buildscript.configurations.classpath
    configFile = file('config/codenarc/codenarc-gradle.groovy')
    source = rootDir
    include '*.gradle', 'config/codenarc/*.groovy'
    ignoreFailures false
    maxPriority1Violations 0
    maxPriority2Violations 0
    maxPriority3Violations 0
}

check {
    dependsOn codenarcGradle
}

gradleLint {
    alwaysRun = false
    criticalRules = ['all-dependency']
    excludedRules = ['recommended-versions']
}

check {
    dependsOn criticalLintGradle
}

spotbugs {
    toolVersion = spotbugsVersion
    ignoreFailures = false
    effort = 'max'
}

pmd {
    toolVersion pmdVersion
    ignoreFailures = false
    consoleOutput = true
}

tasks.withType(Pmd) {
    include '**/*.java'
}

def pmdConfigPath = 'config/pmd'

pmdTest {
    ruleSets = []
    ruleSetFiles = files("$pmdConfigPath/test-ruleset.xml")
}

pmdMain {
    ruleSets = []
    ruleSetFiles = files("$pmdConfigPath/main-ruleset.xml")
}

pmdAcceptanceTest {
    ruleSets = []
    ruleSetFiles = files("$pmdConfigPath/acceptanceTest-ruleset.xml")
}

tasks['check'].dependsOn('markdownlint')

sonarqube {
    properties {
        property 'sonar.projectKey', 'ivankohut_quantifa'
        property 'sonar.qualitygate.wait', true
        property 'sonar.coverage.jacoco.xmlReportPaths', "$buildDir/reports/jacoco/test/jacocoTestReport.xml"
        property 'sonar.coverage.exclusions', '**/Application.java, **/DelayedScalar.java'
    }
}

tasks['sonarqube'].dependsOn test

yamlValidator {
    searchPaths = ['.travis.yml']
}

task writeFitNesseClasspath (type: WriteFitNesseClasspath) {
    classpath = sourceSets.acceptanceTest.runtimeClasspath
    pagePath = project.file(specificationDir)
}

class WriteFitNesseClasspath extends DefaultTask {

    @Input
    FileCollection classpath

    @OutputDirectory
    File pagePath

    @TaskAction
    void generatePage() {
        def outputFile = project.file("${pagePath}/GradleClassPath.wiki")
        outputFile.createNewFile()
        outputFile.withWriter { writer ->
            project.sourceSets.main.output.classesDirs.forEach { classesDir -> writer.writeLine("!path ${classesDir}") }
            classpath.each { d ->
                writer.writeLine("!path $d")
            }
        }
    }

}

task acceptanceTestExecution(type: Test) {
    description = 'Runs acceptance tests.'
    group = 'verification'
    useJUnit()
    testClassesDirs = sourceSets.acceptanceTest.output.classesDirs
    classpath = sourceSets.acceptanceTest.runtimeClasspath
    shouldRunAfter test
}

check {
    dependsOn acceptanceTestExecution
}
